---
Goal

spring-data-jpa의 룰 파악


---
Index


A. 단방향 | 양방향
B. 연관관계의 주인
C. 연관관계 매핑 (1:1, 1:N, N:1, N:M)
D. N+1 problem -> Lazy Loading



---
A. 단방향, 양방향


db에서는 fk로 걸면 두 테이블이 연결되서 방향개념이 없는데,
orm에서는 객체(@Entity)가 다른 객체 참조하면, 방향이 중요함.

Board, Post 두 테이블 중,
Board.getPost() 기능이 필요해서, Board -> Post 참조했으면 단방향 관계,
근데 Post.getBoard() 기능도 필요해서, Post -> Board 까지 참조했으면 양방향 관계.


Q. 왜 굳이 방향 개념이 있는거지?

A. 예를들어, Member -> Book (Member:Book = 1:N) -> Library (Book:Library = N:1) 이런 관계일 때,
Member를 fetch하면, 둘이 연관만 되있으면 Member랑 관련된 Book도 fetch 해 오고, Book에 걸린 Library도 fetch해 오는 식으로 hibernate가 동작하나 봄.

이런 의도하지 않은 불필요한 쿼리가 많이 생기는게 N+1 문제인가 봄.
그래서 EAGER_Loading으로 다 땡겨오는게 아니라, 필요한 부분만 땡겨오는 Lazy_Loading으로 이 문제를 해결하려는 거고.

여튼, 여기서 방향개념이 생긴다면, 둘이 연결되 있지만, 방향이 안맞으면 fetch를 안해오기 때문에, 방향개념을 도입한 듯 하다.




---
B. 연관관계의 주인


Board : Post = 1 : N 관계라고 할 때,
보통 db에서 N쪽인 Post가 1쪽인 Board의 PK를 FK로 받아놓음.
이 때, 1쪽인 Board를 주인, N쪽인 Post를 하인이라고 정의한다.


Q. 근데 왜 연관관계의 주인, 하인 정해야해?

A.
주인은 FK가진 하인 테이블의 CRUD가능.
하인은 주인 테이블 Read밖에 못하기 때문.


아 그러면 Board : Post = 1 : N 관계에서,
Board를 주인으로 정해놓으면,
Board에 read를 하거나 insert를 할 때, 하인인 Post에 대한 정보도 딸려나온다는건가?

만약에 거의 항상 Board read시 해당 Post들을 다 불러오는 구조라면, 이렇게 짜는게 좋은데,
A:B 둘이 1:N 관계는 있는데, A를 쿼리할 때, B정보까진 필요 없으면, 반대로 N:1로 짤 수도 있겠구나.



Q. 어떻게 주인 설정함?

A.
1. 단방향인 경우, 하인에서 @JoinColumn(name = "주인_ID")로 설정하고,
2. 양방향인 경우,
    - 하인에서 @JoinColumn(name = "BOARD_ID")로 정해주면 된다.
    - 주인에서 @OneToMany(mappedBy = "board"), 즉 mappedBy를 써서 주인 엔티티를 적어준다.


example)

case1) 단방향, (Board : Post = 1 : N)

```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;

    @ManyToOne
    @JoinColumn(name = "BOARD_ID")
    private Board board;
    //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;
    //... getter, setter
}
```

Board:Post = 1:N 관계에서,
하인인 Post에서 @ManyToOne으로 주인인 Board를 참조하여 주인의 FK를 가지고 있음.
주인은 참조하지 않는다. 왜? 단뱡항 이니까.


case2) 양방향, (Board : Post = 1 : N)
Q. 만약 @ManyToOne 양방향으로 만들고 싶다면?

```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;

    @ManyToOne
    @JoinColumn(name = "BOARD_ID")
    private Board board;
    //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @OneToMany(mappedBy = "board")
    List<Post> posts = new ArrayList<>();
    //... getter, setter
}
```

이번엔 양방향이니까, 주인에서도 @OneToMany를 추가해준다. mappedBy 주인.
(단방향일 땐 mappedBy 안쓰는데, 양방향일 때에만 mappedBy를 쓴다.)


실무 사용 금지!
Q. 왜 앵간하면 단방향으로 만들라는거지? 왜 양방향이면 안된다는거지?




Q. 만약 주인, 하인의 관계를 바꾼다면?

Board : Post = 1 : N 관계라고 할 때,
Board가 주인이고 Post가 하인이라, Post가 Board의 PK를 FK로 들고있는게 정상인데,
만약 Post가 주인이고 Board가 하인으로 설정한다면 어떤 일이 벌어질까?


```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;
  //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @OneToMany
    @JoinColumn(name = "POST_ID") //일대다 단방향을 @JoinColumn필수
    List<Post> posts = new ArrayList<>();
    //... getter, setter
}
```

단방향이라 Post에는 암것도 없는데, 하인인 Board에는 @OneToMany, @JoinColumn(name = "POST_ID") 이 있다.

Q. 이러면 어떤 문제점이 발생할까?

A. 이렇게 짜면, 주인이 Post고 하인이 Board가 되니까,
주인인 Post는 하인인 Board 테이블에 대해 CRUD가 가능한데,
하인인 Board는 주인인 Post에 대해 Read밖에 할 수 없다.
-> 로직상 이상함


또한, 실제로 hibernate에서 돌아가는 쿼리 봐도 이상함.
```java
//...
Post post = new Post();
post.setTitle("가입인사");

entityManager.persist(post); // post 저장

Board board = new Board();
board.setTitle("자유게시판");
board.getPosts().add(post);

entityManager.persist(board); // board 저장
//...
```

이 경우, 주인인 post 저장시 까지는 괜찮았다가,
하인인 board 저장할 때, insert board 이후, update post 쿼리까지 나감.

board.getPosts().add(post); 이 부분 때문.

하인인 Board를 저장했는데 주인인 Post Update query가 의도치 않게 날아감 -> 쿼리 성능 저하.


결론: 주종관계 정할 때는, 하인쪽에 CRUD하면 주인까지 건드리니까,
1:N관계 같은 곳에서는 1을 하인으로 정하면 1 건드릴 때마다 N을 건드려서 성능저하가 일어난다. 그러니 N을 하인으로 하자.
1:1관계의 경우, 자주 CRUD하는 쪽인 쪽을 주인으로 하자.



---
C. 연관관계 매핑


a. 양방향 @OneToOne
ex. Member : Mypage

@OneToOne은 단방향 지원 안함. 무조건 양방향 이어야 한다.

주인 쪽에서는
```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @OneToOne
    @JoinColumn(name = "ATTACH_ID")
    private Attach attach;
    //... getter,setter
}
@Entity
public class Attach {
    @Id @GeneratedValue
    @Column(name = "ATTACH_ID")
    private Long id;

    @OneToOne(mappedBy = "attach")
    private Post post;
  //... getter, setter
}
```

주인쪽에서는 @JoinColumn(name = "ATTACH_ID") 로 걸고,
하인 쪽에서는 @OneToOne(mappedBy = "attach") 로 양방향으로 건다.


Q. 근데 1:1에서 누가 주인인지 어떻게 정하지?
비지니스 로직은 언제든지 바뀔 수 있는데, db schema는 한번 정해지면 바꾸기 어렵잖아?

A.
생각할 것: FK를 Post 테이블에서 관리해야 하나? 아니면 Attach 테이블에서 관리해야 하나?

만약 하나의 Post에 여러개의 첨부파일을 첨부하는게 비즈니스 로직이라면?
그럼 Attach table이 N이 될 확률이 높으니까 Attach를 하인으로 두고 Post의 FK를 관리하게 해야하나?

반드시 그런 것 만은 아니다.
orm에서 POST가 Attach의 FK를 가지고 있으면(Post가 하인, Attach가 주인),
Post를 조회할 때마다, 이미 Attach의 참조를 가지고 있기 때문에, 성능상 이득이 있다.


양 측 pros and cons 고려해서 구현하고, 이유를 적어놓자.




b. @OneToMany
ex. Member : Book

c. @ManyToOne
ex. Member : Library

d. @ManyToMany
양방향 FK가지고 있기는 거의 안쓴다.

실무 사용 금지.

왜?

N+1 problem문제를 보면, orm 특성상 쿼리시 객체에 연관되있으면 관련 테이블도 죄다 fetch해오는 문제가 있어서,
딱 요청한 것만 꺼내오는 Lazy_Loading으로 해결하는데,
@ManyToMany의 경우, join이 양방향으로 엮여있다 보니까, 서로 객체가 가지고 있는 FK 죄다 fetch해오니까,
의도하지 않은 쿼리들이 많이 발생할 수 있기 때문.


따라서 설계 시 최대한 단방향으로 설계를 하고,
꼭 필요한 부분을 양방향으로 조심히 처리하자.


---
D. N+1 problem

연관관계를 갖고있는 객체를 조회하면 JPA는 해당 객체가 들고있는 연관관계의 객체들을 모두 조회해서 끌고오게 된다.
이때 발생하는 문제가 1 + N 쿼리 문제.

example)
하나의 서점을 조회했는데 해당 객체가 3개의 책을 갖고있고 각 책들은 2개의 편집자 정보를 갖고있다고 해보자.

그럼 서점 -> 책 -> 편집자 정보로 이어지는 조회가 발생하게 된다.
따라서 1번 (서점) + 3번 (책) + 6번 (편집자) 해서 총 1 + 9번의 쿼리가 발생하게 된다.
따라서 일대다 방식에서는 Lazy 방식을 지향한다.



Solutions

1. 즉시로딩 _ (FetchType.EAGER)
연관된 객체를 즉시 가져오는 방식이다.
연관된 객체가 사용되지 않더라도 일단 모두 조회해온다.

2. 지연로딩 _ (FetchType.LAZY)
연관 객체를 프록시 객체로 치환하여 껍데기 객체로 대치하여 추후 직접적인 조회가 발생하면 가져오는 방식이다.
꼭 필요할 때 까지 조회를 미루는 것이다.

쿼리 두번하잖아욧! -> FetchType.EAGER 로 하면 쿼리 한방에 다 가져오긴 하지. 근데 의도치 않게 많이 가져온다는게 문제지만.

(참고로 일대일에서는 단방향 관계에서만 LAZY로딩이 가능하다. 양방향이면 LAZY로 해도 EAGER로 작동한다.)
(단방향: TableA가 TableB의 FK 가지는 것. 양방향: TableA, TableB가 서로의 FK를 가지는 것)



