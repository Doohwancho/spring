---
Goal

spring-data-jpa의 룰 파악


---
Index


A. 단방향 | 양방향
B. 연관관계의 주인
C. 연관관계 매핑 (1:1, 1:N, N:1, N:M)
D. N+1 problem -> Lazy Loading



---
A. 단방향, 양방향


db에서는 fk로 걸면 두 테이블이 연결되서 방향개념이 없는데,
orm에서는 객체(@Entity)가 다른 객체 참조하면, 방향이 중요함.

Board, Post 두 테이블 중,
Board.getPost() 기능이 필요해서, Board -> Post 참조했으면 단방향 관계,
근데 Post.getBoard() 기능도 필요해서, Post -> Board 까지 참조했으면 양방향 관계.


Q. 왜 굳이 방향 개념이 있는거지?

A. 예를들어, Member -> Book (Member:Book = 1:N) -> Library (Book:Library = N:1) 이런 관계일 때,
Member를 fetch하면, 둘이 연관만 되있으면 Member랑 관련된 Book도 fetch 해 오고, Book에 걸린 Library도 fetch해 오는 식으로 hibernate가 동작하나 봄.

이런 의도하지 않은 불필요한 쿼리가 많이 생기는게 N+1 문제인가 봄.
그래서 EAGER_Loading으로 다 땡겨오는게 아니라, 필요한 부분만 땡겨오는 Lazy_Loading으로 이 문제를 해결하려는 거고.

여튼, 여기서 방향개념이 생긴다면, 둘이 연결되 있지만, 방향이 안맞으면 fetch를 안해오기 때문에, 방향개념을 도입한 듯 하다.




---
B. 연관관계의 주인

주인이 FK를 관리(등록, 수정, 삭제)한다.
따라서 주인은 FK를 가지고 있는 쪽이다.
주인은 mappedBy 속성을 사용하지 않는다.
하인은 mappedBy 속성을 사용해서 주인을 지정해야 한다.

Member:Team = N:1의 관계일 때,
rdb에서 보통은 N쪽이 1의 FK를 가지고 있으므로,
FK를 관리하는 Member가 주인이고, Team이 하인이다.
mappedBy는 하인이 가지고 있어야 하기 때문에, Team쪽에서 엮어준다.

```java
@Entity
@Getter
@Setter
public class Member {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String name;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
}

@Entity
@Getter
@Setter
public class Team {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
}
```

N쪽이라 주인인 Member에서 Team을 @ManyToOne으로 묶어주고 있고,
1쪽이라 하인인 Team에서 Member를 mappedBy로 주인으로 지정하는데, 여기서 "team"은 주인 클래스에서 하인 필드의 변수이름이다.


Q. 만약 하인쪽에 @OneToMany(mappedBy = "team")가 없었다면?
A. 그러면 Member:Team = N:1 단방향 매핑이었겠지. 양방향이 아니라.
만약 그랬다면,

```java
Team team = new Team();
team.setName("teamA");
em.persist(team);

Member member = new Member();
member.setName("member1");
member.setTeam(team);
em.persist(member);

Member findMember = em.find(Member.class, member.getId());
Team findTeam = findMember.getTeam();
```

Member -> Team으로 단방향 @ManyToOne이니까, findMember.getTeam()으로 멤버에서 팀을 가져올 순 있었겠지만,
팀에서 멤버를 가져오진 못했겠지.


Q. Member:Team = N:1 양방향으로 매핑하고 싶다면?
A. 하인쪽인 Team에 만약 하인쪽에 @OneToMany(mappedBy = "team")을 넣으면 양방향이 되지.

```java
Member findMember = em.find(Member.class, member.getId());

Team findTeam = findMember.getTeam();
List<Member> members = findTeam.getMembers();
members.stream().forEach(m-> System.out.println(m.getName()));
```

그러면, 팀에서도 Member를 가져올 수 있지. findTeam.getMembers()로.



Q. 만약 하인에게 주인을 넣으면?
주인이 FK를 관리하고, 주인은 하인의 CRUD가능하지만, 하인은 주인의 READ밖에 못한다며?
만약 하인인 Team에서 주인을 더하면 어떻게 됨?

```java
Member member = new Member();
member.setName("member1");
em.persist(member);

Team team = new Team();
team.setName("teamA");
team.getMembers().add(member);
em.persist(team);
```

Team.member에 FK가 안들어가는 사태 발생.
하인은 주인을 READ만 가능하지, WRITE는 못한다.


```java
Team team = new Team();
team.setName("teamA");
em.persist(team);

member member = new Member();
member.setName("member1");
member.setTeam(team);
em.persist(member);

team.getMembers().add(member);
```

이런 식으로 주인에서 하인을 먼저 더한 후,
하인에서 주인을 더해주는건 가능.
양쪽에 넣어줘야 함






example2) Board : Post = 1 : N


case1) 단방향, (Board : Post = 1 : N)

```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;

    @ManyToOne
    @JoinColumn(name = "BOARD_ID")
    private Board board;
    //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;
    //... getter, setter
}
```

Board:Post = 1:N 관계에서,
주인인 Post에서 @ManyToOne으로 하인인 Board를 참조하여 주인의 FK를 가지고 있음.


case2) 양방향, (Board : Post = 1 : N)
Q. 만약 @ManyToOne 양방향으로 만들고 싶다면?

```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;

    @ManyToOne
    @JoinColumn(name = "BOARD_ID")
    private Board board;
    //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @OneToMany(mappedBy = "board")
    List<Post> posts = new ArrayList<>();
    //... getter, setter
}
```

이번엔 양방향이니까, 하인에서도 @OneToMany를 추가해준다. mappedBy 주인.
(단방향일 땐 mappedBy 안쓰는데, 양방향일 때에만 mappedBy를 쓴다.)


실무 사용 금지!
Q. 왜 앵간하면 단방향으로 만들라는거지? 왜 양방향이면 안된다는거지?



Q. 만약 주인, 하인의 관계를 바꾼다면?

Board : Post = 1 : N 관계라고 할 때,
Board가 하인이고 Post가 주인이라, Post가 Board의 PK를 FK로 들고있는게 정상인데,
만약 Board가 주인이고 Post가 하인으로 설정한다면 어떤 일이 벌어질까?


```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;
  //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @OneToMany
    @JoinColumn(name = "POST_ID") //일대다 단방향을 @JoinColumn필수
    List<Post> posts = new ArrayList<>();
    //... getter, setter
}
```


Q. 이러면 어떤 문제점이 발생할까?

A. 이렇게 짜면, Board : Post = 1 : N에서 주인이 Post, 하인이 Board가 되야 하는데, 주인이 Board, 하인이 Post가 된다.
주인인 Board는 하인인 Post 테이블에 대해 CRUD가 가능한데,
하인인 Post는 주인인 Board에 대해 Read밖에 할 수 없다.

실제로 hibernate에서 돌아가는 쿼리 봐도 이상함.
```java
//...
Post post = new Post();
post.setTitle("가입인사");

entityManager.persist(post); // post 저장. 여기 까진 괜찮음

Board board = new Board();
board.setTitle("자유게시판");
board.getPosts().add(post); //여기서 문제 발생

entityManager.persist(board); // board 저장
//...
```

이 경우, 주인인 post 저장시 까지는 괜찮았다가,
하인인 board 저장할 때, insert board 이후, update post 쿼리까지 나감.

board.getPosts().add(post); 이 부분 때문.

주인인 Board를 저장했는데 하인인 Post Update query가 의도치 않게 날아감 -> 쿼리 성능 저하.

(원래대로 였다면, Post가 주인이고 하인인 Board이니까, 게시판에 글(Post)이 달리면 게시판인 Board도 업데이트 되어야 하니까 그게 맞는데, 이 케이스는 주종관계 뒤집혀서 이상해짐)


결론: 주종관계 정할 때는, 하인쪽에 CRUD하면 주인까지 건드리니까,
1:N관계 같은 곳에서는 1을 주인으로 정하면 1 건드릴 때마다 N을 건드려서 성능저하가 일어난다. 그러니 N을 주인으로 하자.
1:1관계의 경우, 자주 CRUD하는 쪽인 쪽을 주인으로 하자.



---
C. 연관관계 매핑


a. 양방향 @OneToOne
ex. Member : Mypage

@OneToOne은 단방향 지원 안함. 무조건 양방향 이어야 한다.


```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @OneToOne
    @JoinColumn(name = "ATTACH_ID")
    private Attach attach;
    //... getter,setter
}
@Entity
public class Attach {
    @Id @GeneratedValue
    @Column(name = "ATTACH_ID")
    private Long id;

    @OneToOne(mappedBy = "attach")
    private Post post;
  //... getter, setter
}
```

주인쪽에서는 @JoinColumn(name = "ATTACH_ID") 로 걸고,
하인 쪽에서는 @OneToOne(mappedBy = "attach") 로 양방향으로 건다.


Q. 근데 1:1에서 누가 주인인지 어떻게 정하지?
비지니스 로직은 언제든지 바뀔 수 있는데, db schema는 한번 정해지면 바꾸기 어렵잖아?

A.
생각할 것: FK를 Post 테이블에서 관리해야 하나? 아니면 Attach 테이블에서 관리해야 하나?

만약 하나의 Post에 여러개의 첨부파일을 첨부하는게 비즈니스 로직이라면?
그럼 Attach table이 N이 될 확률이 높으니까 Attach를 주인으로 두고 Post의 PK를 FK로 받아 관리하게 해야하나?

반드시 그런 것 만은 아니다.
만약 반대로 POST가 Attach의 FK를 가지고 있으면(Post가 주인, Attach가 하인),
Post를 조회할 때마다, 이미 Attach의 참조를 가지고 있기 때문에, 성능상 이득이 있다.

그렇기 때문에 1:1 관계에서는, 한쪽이 N이 될 확률이 더 높다고 주인으로 설정하기 보다는,
A쪽을 CRUD시 B쪽의 참조를 가지고 있는게 더 유리하면, A쪽을 주인으로 설정하는게 좋다.





b. @OneToMany
ex. Member : Book

c. @ManyToOne
ex. Member : Library

d. @ManyToMany
양방향 FK가지고 있기는 거의 안쓴다.

실무 사용 금지.

왜?

N+1 problem문제를 보면, orm 특성상 쿼리시 객체에 연관되있으면 관련 테이블도 죄다 fetch해오는 문제가 있어서,
딱 요청한 것만 꺼내오는 Lazy_Loading으로 해결하는데,
@ManyToMany의 경우, join이 양방향으로 엮여있다 보니까, 서로 객체가 가지고 있는 FK 죄다 fetch해오니까,
의도하지 않은 쿼리들이 많이 발생할 수 있기 때문.


따라서 설계 시 최대한 단방향으로 설계를 하고,
꼭 필요한 부분을 양방향으로 조심히 처리하자.


---
D. N+1 problem

연관관계를 갖고있는 객체를 조회하면 JPA는 해당 객체가 들고있는 연관관계의 객체들을 모두 조회해서 끌고오게 된다.
이때 발생하는 문제가 1 + N 쿼리 문제.

example)
하나의 서점을 조회했는데 해당 객체가 3개의 책을 갖고있고 각 책들은 2개의 편집자 정보를 갖고있다고 해보자.

그럼 서점 -> 책 -> 편집자 정보로 이어지는 조회가 발생하게 된다.
따라서 1번 (서점) + 3번 (책) + 6번 (편집자) 해서 총 1 + 9번의 쿼리가 발생하게 된다.
따라서 일대다 방식에서는 Lazy 방식을 지향한다.



Solutions

1. 즉시로딩 _ (FetchType.EAGER)
연관된 객체를 즉시 가져오는 방식이다.
연관된 객체가 사용되지 않더라도 일단 모두 조회해온다.

2. 지연로딩 _ (FetchType.LAZY)
연관 객체를 프록시 객체로 치환하여 껍데기 객체로 대치하여 추후 직접적인 조회가 발생하면 가져오는 방식이다.
꼭 필요할 때 까지 조회를 미루는 것이다.

쿼리 두번하잖아욧! -> FetchType.EAGER 로 하면 쿼리 한방에 다 가져오긴 하지. 근데 의도치 않게 많이 가져온다는게 문제지만.

(참고로 일대일에서는 단방향 관계에서만 LAZY로딩이 가능하다. 양방향이면 LAZY로 해도 EAGER로 작동한다.)
(단방향: TableA가 TableB의 FK 가지는 것. 양방향: TableA, TableB가 서로의 FK를 가지는 것)



