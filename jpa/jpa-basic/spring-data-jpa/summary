---
Index

A. 연관관계 매핑
B. N+1 problem -> Lazy Loading

---
A. 연관관계 매핑

주의: 단방향 매핑 위주로 설계. 양방향은 최대한 지양. 이유는 @ManyToMany에 적혀있다.


a. @OneToOne
ex. Member : Mypage

b. @OneToMany
ex. Member : Book

c. @ManyToOne
ex. Member : Library

d. @ManyToMany
양방향 FK가지고 있기는 거의 안쓴다.

왜?

N+1 problem문제를 보면, orm 특성상 쿼리시 객체에 연관되있으면 관련 테이블도 죄다 fetch해오는 문제가 있어서,
딱 요청한 것만 꺼내오는 Lazy_Loading으로 해결하는데,
@ManyToMany의 경우, join이 양방향으로 엮여있다 보니까, 서로 객체가 가지고 있는 FK 죄다 fetch해오니까,
의도하지 않은 쿼리들이 많이 발생할 수 있기 때문.


따라서 설계 시 최대한 단방향으로 설계를 하고,
꼭 필요한 부분을 양방향으로 조심히 처리하자.


---
B. N+1 problem

연관관계를 갖고있는 객체를 조회하면 JPA는 해당 객체가 들고있는 연관관계의 객체들을 모두 조회해서 끌고오게 된다.
이때 발생하는 문제가 1 + N 쿼리 문제.

example)
하나의 서점을 조회했는데 해당 객체가 3개의 책을 갖고있고 각 책들은 2개의 편집자 정보를 갖고있다고 해보자.

그럼 서점 -> 책 -> 편집자 정보로 이어지는 조회가 발생하게 된다.
따라서 1번 (서점) + 3번 (책) + 6번 (편집자) 해서 총 1 + 9번의 쿼리가 발생하게 된다.
따라서 일대다 방식에서는 Lazy 방식을 지향한다.



Solutions

1. 즉시로딩 _ (FetchType.EAGER)
연관된 객체를 즉시 가져오는 방식이다.
연관된 객체가 사용되지 않더라도 일단 모두 조회해온다.

2. 지연로딩 _ (FetchType.LAZY)
연관 객체를 프록시 객체로 치환하여 껍데기 객체로 대치하여 추후 직접적인 조회가 발생하면 가져오는 방식이다.
조회를 미루는 것이다.

(참고로 일대일에서는 단방향 관계에서만 LAZY로딩이 가능하다. 양방향이면 LAZY로 해도 EAGER로 작동한다.)
(단방향: TableA가 TableB의 FK 가지는 것. 양방향: TableA, TableB가 서로의 FK를 가지는 것)



