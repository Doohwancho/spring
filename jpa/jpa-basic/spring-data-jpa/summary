---
Goal

spring-data-jpa의 룰 파악


---
Index

A. 매핑 어노테이션 정리
B. 식별자 매핑 어노테이션 정리
C. 단방향 | 양방향
D. 연관관계의 주인
E. 연관관계 매핑 (1:1, 1:N, N:1, N:M)
F. N+1 problem -> Lazy Loading



---
A. 매핑 어노테이션 정리


-   @Column
    -   @Column(name = "USERNAME")
    -   name
        -   필드와 매핑할 테이블의 컬럼 이름
    -   insertable, updatable
        -   TRUE/FALSE 설정. 읽기 전용
    -   nullable
        -   null 허용여부 결정, DDL 생성시 사용(not null 추가)
    -   unique
        -   유니크 제약 조건, DDL 생성시 사용
    -   columnDefinition, length, precision, scale(DDL)
-   @Temporal
    -   @Temporal(TemporalType.TIMESTAMP)
    -   시간과 관련된 매핑
    -   Date 뿐만아니라 자바8에서 지원하는 LocalDatetime도 지원한다.
-   @Enumerates
    -   @Enumerated(EnumType.STRING)
    -   자바의 Enum 타입 매핑을 지원한다.
    -   현업에서는 EnumType을 무조건 STRING으로 지정 해야한다.
    -   기본 값인 ORDINAL로 설정하면 Enum 순서로 숫자가 매핑되는데, Enum 중간에 필드가 하나 추가 되면 다 꼬이게 된다.
-   @Lob
    -   컨텐츠의 길이가 너무 길 경우 바이너리 파일로 DB에 바로 밀어 넣어야 하는데, 보통 이런 경우에 사용한다.
    -   공통적으로 @Lob으로 사용하면 된다.
    -   CLOB, BLOB 매핑
    -   CLOB : String, char[], java.sql.CLOB
    -   BLOB : byte[], java.sql.BLOB
-   @Transient
    -   이 필드는 매핑하지 않는다.
    -   애플리케이션에서 DB에 저장하지 않는 필드
    -   웬만하면 쓰지 않는 것이...


---
B. 식별자 매핑 어노테이션 정리


a. 식별자 매핑 어노테이션

-   @Id(직접 매핑)
-   @GeneratedValue(strategy = GenerationType.[**타입**])
    -   타입 설정
        -   IDENTITY
            -   데이터베이스에 위임, MYSQL, ORACLE 등 db vendor에 의존적.
            -   IDENTITY 는 id 값을 세팅하지 않고, insert 쿼리를 날리면 database 시스템에서 자동으로 채번을 합니다.
            -   AUTO_INCREMENT 라고도 하며, INSERT 쿼리가 실행된 이후에야 ID 값을 알 수 있습니다.
            -   id 값 생성에 대해서 database 에서 관여하기에 save 메소드를 수행시 persist 로 동작하게 됩니다
        -   SEQUENCE
            -   데이터베이스 시퀀스 오브젝트 사용, ORACLE
            -   @SequenceGenerator 필요
            -   동작방식
                -   persist 를 호출하면 (spring data jpa 의 경우 save) sequence 를 가져옵니다.
                -   sequence generator에서 가져온 Sequence 를 id 에 할당하고 (영속성 상태), transaction 이 commit 될 때, insert 쿼리를 날립니다.
        -   TABLE
            -   키 생성용 테이블 사용, 모든 DB에서 사용 가능.
            -   @TableGenerator 필요
            -   단점: Sequence 나 Identity 방식은 하나의 Request 로 처리가 가능하지만 테이블 생성전략은 3개의 스텝이 필요합니다.
            -   lock 을 잡고, seq 를 증가시키고 데이터베이스에 저장합니다. (리소스 소모)
            -   그렇기에 운영에서 잘 안쓴다.
        -   AUTO
            -   방언에 따라 자동 지정, 기본값



b. 권장 식별자 전략

-   기본 키 제약 조건
    -  NOT NULL
    -  UNIQUE, one and only
    -  변하면 안된다.
-   미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자.
    -   예를 들어 주민등록번호도 기본 키로 적절하지 않다.
    -   주민번호를 PK로 설정하고 다른 테이블과 FK 참조시 그대로 주민번호가 넘어간다. 갑자기 나라에서 개인정보 목적으로 "DB에 주민번호 저장하지 마라"라고 한다. 헬게이트 오픈
-   **권장**
    -   **Long + 대체키 + 키 생성전략 사용**
    -   대체키는 전혀 비즈니스랑 관계없는 키.
    -   AUTO_INCREMENT로 숫자로 PK를 사용하면, int쓰면 안된다. 생각보다 금방 끝난다..
    -   Long 타입으로.



---
C. 단방향, 양방향


db에서는 fk로 걸면 두 테이블이 연결되서 방향개념이 없는데,
orm에서는 객체(@Entity)가 다른 객체 참조하면, 방향이 중요함.

Board, Post 두 테이블 중,
Board.getPost() 기능이 필요해서, Board -> Post 참조했으면 단방향 관계,
근데 Post.getBoard() 기능도 필요해서, Post -> Board 까지 참조했으면 양방향 관계.


Q. 왜 굳이 방향 개념이 있는거지?

A. 예를들어, Member -> Book (Member:Book = 1:N) -> Library (Book:Library = N:1) 이런 관계일 때,
Member를 fetch하면, 둘이 연관만 되있으면 Member랑 관련된 Book도 fetch 해 오고, Book에 걸린 Library도 fetch해 오는 식으로 hibernate가 동작하나 봄.

이런 의도하지 않은 불필요한 쿼리가 많이 생기는게 N+1 문제인가 봄.
그래서 EAGER_Loading으로 다 땡겨오는게 아니라, 필요한 부분만 땡겨오는 Lazy_Loading으로 이 문제를 해결하려는 거고.

여튼, 여기서 방향개념이 생긴다면, 둘이 연결되 있지만, 방향이 안맞으면 fetch를 안해오기 때문에, 방향개념을 도입한 듯 하다.




---
D. 연관관계의 주인

주인이 FK를 관리(등록, 수정, 삭제)한다.
따라서 주인은 FK를 가지고 있는 쪽이다.
주인은 mappedBy 속성을 사용하지 않는다.
하인은 mappedBy 속성을 사용해서 주인을 지정해야 한다.

Member:Team = N:1의 관계일 때,
rdb에서 보통은 N쪽이 1의 FK를 가지고 있으므로,
FK를 관리하는 Member가 주인이고, Team이 하인이다.
mappedBy는 하인이 가지고 있어야 하기 때문에, Team쪽에서 엮어준다.


```java
@Entity
@Getter
@Setter
public class Member {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String name;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
}

@Entity
@Getter
@Setter
public class Team {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
}
```

N쪽이라 주인인 Member에서 Team을 @ManyToOne으로 묶어주고 있고,
1쪽이라 하인인 Team에서 Member를 mappedBy로 주인으로 지정하는데, 여기서 "team"은 주인 클래스에서 하인 필드의 변수이름이다.


Q. 만약 하인쪽에 @OneToMany(mappedBy = "team")가 없었다면?
A. 그러면 Member:Team = N:1 단방향 매핑이었겠지. 양방향이 아니라.
만약 그랬다면,

```java
Team team = new Team();
team.setName("teamA");
em.persist(team);

Member member = new Member();
member.setName("member1");
member.setTeam(team);
em.persist(member);

Member findMember = em.find(Member.class, member.getId());
Team findTeam = findMember.getTeam();
```

Member -> Team으로 단방향 @ManyToOne이니까, findMember.getTeam()으로 멤버에서 팀을 가져올 순 있었겠지만,
팀에서 멤버를 가져오진 못했겠지.


Q. Member:Team = N:1 양방향으로 매핑하고 싶다면?
A. 하인쪽인 Team에 만약 하인쪽에 @OneToMany(mappedBy = "team")을 넣으면 양방향이 되지.

```java
Member findMember = em.find(Member.class, member.getId());

Team findTeam = findMember.getTeam();
List<Member> members = findTeam.getMembers();
members.stream().forEach(m-> System.out.println(m.getName()));
```

그러면, 팀에서도 Member를 가져올 수 있지. findTeam.getMembers()로.



Q. 만약 하인에게 주인을 넣으면?
주인이 FK를 관리하고, 주인은 하인의 CRUD가능하지만, 하인은 주인의 READ밖에 못한다며?
만약 하인인 Team에서 주인을 더하면 어떻게 됨?

```java
Member member = new Member();
member.setName("member1");
em.persist(member);

Team team = new Team();
team.setName("teamA");
team.getMembers().add(member);
em.persist(team);
```

Team.member에 FK가 안들어가는 사태 발생.
하인은 주인을 READ만 가능하지, WRITE는 못한다.


```java
Team team = new Team();
team.setName("teamA");
em.persist(team);

member member = new Member();
member.setName("member1");
member.setTeam(team);
em.persist(member);

team.getMembers().add(member);
```

이런 식으로 주인에서 하인을 먼저 더한 후,
하인에서 주인을 더해주는건 가능.
양쪽에 넣어줘야 함






example2) Board : Post = 1 : N


case1) 단방향, (Board : Post = 1 : N)

```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;

    @ManyToOne
    @JoinColumn(name = "BOARD_ID")
    private Board board;
    //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;
    //... getter, setter
}
```

Board:Post = 1:N 관계에서,
주인인 Post에서 @ManyToOne으로 하인인 Board를 참조하여 주인의 FK를 가지고 있음.


case2) 양방향, (Board : Post = 1 : N)
Q. 만약 @ManyToOne 양방향으로 만들고 싶다면?

```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;

    @ManyToOne
    @JoinColumn(name = "BOARD_ID")
    private Board board;
    //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @OneToMany(mappedBy = "board")
    List<Post> posts = new ArrayList<>();
    //... getter, setter
}
```

이번엔 양방향이니까, 하인에서도 @OneToMany를 추가해준다. mappedBy 주인.
(단방향일 땐 mappedBy 안쓰는데, 양방향일 때에만 mappedBy를 쓴다.)


실무 사용 금지!
Q. 왜 앵간하면 단방향으로 만들라는거지? 왜 양방향이면 안된다는거지?



Q. 만약 주인, 하인의 관계를 바꾼다면?

Board : Post = 1 : N 관계라고 할 때,
Board가 하인이고 Post가 주인이라, Post가 Board의 PK를 FK로 들고있는게 정상인데,
만약 Board가 주인이고 Post가 하인으로 설정한다면 어떤 일이 벌어질까?


```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;
  //... getter, setter
}

@Entity
public class Board {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @OneToMany
    @JoinColumn(name = "POST_ID") //일대다 단방향을 @JoinColumn필수
    List<Post> posts = new ArrayList<>();
    //... getter, setter
}
```


Q. 이러면 어떤 문제점이 발생할까?

A. 이렇게 짜면, Board : Post = 1 : N에서 주인이 Post, 하인이 Board가 되야 하는데, 주인이 Board, 하인이 Post가 된다.
주인인 Board는 하인인 Post 테이블에 대해 CRUD가 가능한데,
하인인 Post는 주인인 Board에 대해 Read밖에 할 수 없다.

실제로 hibernate에서 돌아가는 쿼리 봐도 이상함.
```java
//...
Post post = new Post();
post.setTitle("가입인사");

entityManager.persist(post); // post 저장. 여기 까진 괜찮음

Board board = new Board();
board.setTitle("자유게시판");
board.getPosts().add(post); //여기서 문제 발생

entityManager.persist(board); // board 저장
//...
```

이 경우, 주인인 post 저장시 까지는 괜찮았다가,
하인인 board 저장할 때, insert board 이후, update post 쿼리까지 나감.

board.getPosts().add(post); 이 부분 때문.

주인인 Board를 저장했는데 하인인 Post Update query가 의도치 않게 날아감 -> 쿼리 성능 저하.

(원래대로 였다면, Post가 주인이고 하인인 Board이니까, 게시판에 글(Post)이 달리면 게시판인 Board도 업데이트 되어야 하니까 그게 맞는데, 이 케이스는 주종관계 뒤집혀서 이상해짐)


결론: 주종관계 정할 때는, 하인쪽에 CRUD하면 주인까지 건드리니까,
1:N관계 같은 곳에서는 1을 주인으로 정하면 1 건드릴 때마다 N을 건드려서 성능저하가 일어난다. 그러니 N을 주인으로 하자.
1:1관계의 경우, 자주 CRUD하는 쪽인 쪽을 주인으로 하자.



---
E. 연관관계 매핑


a. 양방향 @OneToOne
ex. Member : Mypage


```java
@Entity
public class Post {
    @Id @GeneratedValue
    @Column(name = "POST_ID")
    private Long id;

    @OneToOne
    @JoinColumn(name = "ATTACH_ID")
    private Attach attach;
    //... getter,setter
}
@Entity
public class Attach {
    @Id @GeneratedValue
    @Column(name = "ATTACH_ID")
    private Long id;

    @OneToOne(mappedBy = "attach")
    private Post post;
  //... getter, setter
}
```

주인쪽에서는 @JoinColumn(name = "ATTACH_ID") 로 걸고,
하인 쪽에서는 @OneToOne(mappedBy = "attach") 로 양방향으로 건다.


Q. 근데 1:1에서 누가 주인인지 어떻게 정하지?
비지니스 로직은 언제든지 바뀔 수 있는데, db schema는 한번 정해지면 바꾸기 어렵잖아?

A.
생각할 것: FK를 Post 테이블에서 관리해야 하나? 아니면 Attach 테이블에서 관리해야 하나?

만약 하나의 Post에 여러개의 첨부파일을 첨부하는게 비즈니스 로직이라면?
그럼 Attach table이 N이 될 확률이 높으니까 Attach를 주인으로 두고 Post의 PK를 FK로 받아 관리하게 해야하나?

반드시 그런 것 만은 아니다.
만약 반대로 POST가 Attach의 FK를 가지고 있으면(Post가 주인, Attach가 하인),
Post를 조회할 때마다, 이미 Attach의 참조를 가지고 있기 때문에, 성능상 이득이 있다.

그렇기 때문에 1:1 관계에서는, 한쪽이 N이 될 확률이 더 높다고 주인으로 설정하기 보다는,
A쪽을 CRUD시 B쪽의 참조를 가지고 있는게 더 유리하면, A쪽을 주인으로 설정하는게 좋다.


Q. 근데 1대1 단방향은?

참고사항
 * 일대일 관계에서 단방향이 아닌 양방향을 하게되면 Lazy Loading이 작동하지 않는다.
 * 따라서 1 + N문제가 발생할 수 있으므로 조회시 Fetch join을 쓰거나 단방향으로 수정해서 Lazy loading이 되도록 해야한다.



b. @ManyToOne
ex. Member : Library = N:1

가장 보편적인 사용 방법.
최대한 단방향 다대일을 쓰고, 꼭 필요한 경우만 양방향 다대일을 쓴다.


b. @OneToMany
ex. Member : Book

Q. 다대일이랑 일대 다랑 같은거 아냐?
A. 둘 다 @ManyToOne인데, 다대일은 FK관리하는 주인이 다 쪽인데, 일대다는 주인을 1쪽으로 설정한 것
-> 안티 패턴

무슨 차이인지 코드로 알아보자.

예시1) 다대일 정상적인 코드

```java
@Entity
@Getter
@Setter
@Table(name ="MEMBER")
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID)
    private Team team;
}
@Entity
@Getter
@Setter
@Table(name ="TEAM")
public class Team {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
}
```

Member:Team = N:1 양방향이다.
큰 특이점은 없다.


case2) 일대다 비정상 코드

```java
@Entity
@Getter
@Setter
@Table(name ="MEMBER")
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;
}
@Entity
@Getter
@Setter
@Table(name ="TEAM")
public class Team {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany
    @JoinColumn(name = "TEAM_ID")
    private List<Member> members = new ArrayList<>();
}
```

Member:Team = N:1 단방향인데, 보통 주인쪽에서 쓰는 @JoinColumn을 하인에서 썼다.
그래서 Team이 주인이 되었고, Member가 하인이 되었다.

Q. 이러면 무슨 문제가 발생?

```java
Member member = new Member();
member.setUsername("member1");

em.persist(member);

Team team = new Team();
team.setName("teamA");
team.getMembers().add(member); //이 부분이 문제!
```

Team에서 멤버를 더할 때, Member에 update 쿼리가 한번 더 나간다는 문제 발생!
왜?
주인을 CRUD하면 하인까지 update되니까.

차라리 일대다 하지 말고, 다대일에 양방향으로 짜는것이 추천된다.





d. @ManyToMany
양방향 FK가지고 있기는 거의 안쓴다.

실무 사용 금지.

왜?

N+1 problem문제를 보면, orm 특성상 쿼리시 객체에 연관되있으면 관련 테이블도 죄다 fetch해오는 문제가 있어서,
딱 요청한 것만 꺼내오는 Lazy_Loading으로 해결하는데,
@ManyToMany의 경우, join이 양방향으로 엮여있다 보니까, 서로 객체가 가지고 있는 FK 죄다 fetch해오니까,
의도하지 않은 쿼리들이 많이 발생할 수 있기 때문.


따라서 설계 시 최대한 단방향으로 설계를 하고,
꼭 필요한 부분을 양방향으로 조심히 처리하자.


---
F. N+1 problem

연관관계를 갖고있는 객체를 조회하면 JPA는 해당 객체가 들고있는 연관관계의 객체들을 모두 조회해서 끌고오게 된다.
이때 발생하는 문제가 1 + N 쿼리 문제.

example)
하나의 서점을 조회했는데 해당 객체가 3개의 책을 갖고있고 각 책들은 2개의 편집자 정보를 갖고있다고 해보자.

그럼 서점 -> 책 -> 편집자 정보로 이어지는 조회가 발생하게 된다.
따라서 1번 (서점) + 3번 (책) + 6번 (편집자) 해서 총 1 + 9번의 쿼리가 발생하게 된다.
따라서 일대다 방식에서는 Lazy 방식을 지향한다.



Solutions

1. 즉시로딩 _ (FetchType.EAGER)
연관된 객체를 즉시 가져오는 방식이다.
연관된 객체가 사용되지 않더라도 일단 모두 조회해온다.

2. 지연로딩 _ (FetchType.LAZY)
연관 객체를 프록시 객체로 치환하여 껍데기 객체로 대치하여 추후 직접적인 조회가 발생하면 가져오는 방식이다.
꼭 필요할 때 까지 조회를 미루는 것이다.

쿼리 두번하잖아욧! -> FetchType.EAGER 로 하면 쿼리 한방에 다 가져오긴 하지. 근데 의도치 않게 많이 가져온다는게 문제지만.

(참고로 일대일에서는 단방향 관계에서만 LAZY로딩이 가능하다. 양방향이면 LAZY로 해도 EAGER로 작동한다.)
(단방향: TableA가 TableB의 FK 가지는 것. 양방향: TableA, TableB가 서로의 FK를 가지는 것)



