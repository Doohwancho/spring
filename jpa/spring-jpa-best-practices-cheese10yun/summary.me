

---
A. annotations

a. VO on class
@Entity
@Table(name = "account")


b. VO on fields
@Id
@GeneratedValue - auto-increment
@Email
@Column(name = "email", nullable = false, unique = true) - db 제약사항 설정
@NotEmpty
@Temporal(TemporalType.TIMESTAMP)
@CreationTimestamp - 생성시 jvm 시간 기준으로 Timestamp 생성
@UpdateTimestamp - update시 jvm 시간 기준으로 Timestamp 생성




---
B-1. @Valid -> error 처리


vo에 @NotEmpty같은 조건 달고,
controller 파라미터에 @Valid 달아서, 조건에 부합하는지 체크,
틀리면, error 처리를 하는데,
@ControllerAdvice 를 써서 ErrorExceptionController로 컨트롤러에 프록시 담.
특정 exception이 발생하면, 캐치해서 에러 처리해주는 함수 작성. (ex. @ExceptionHandler(EmailDuplicationException.class)가 캐치)


Q. 근데 왜 별개로 에러 처리해줘야해? 기본 기능 쓰면 안돼?
A.
기본 에러 response엔 시스템 정보같은 보여주기 껄끄러운 정보들도 잡다하게 들어가있고, 포멧도 제각각임.
결국 error response 처리를 프론트엔드에서 해줘야 하는데, 포멧 통일시켜주려면, 커스텀으로 만드는게 좋다.
error response template은 ErrorResponse.java임.


example)

swagger2로 post register에 다음과 같이 필드 하나 빼고 보내면, (firstname이 비어있음)

{
  "address1": "address1",
  "address2": "address2",
  "email": "mail@gmail.com",
  "firstName": "",
  "lastName": "cho",
  "password": "1234",
  "zip": "zip code"
}


controller에 @Valid에서 제한사항 체크 중, @NotNull에 걸려서,

{
  "message": "입력값이 올바르지 않습니다.",
  "code": "???",
  "status": 400,
  "errors": [
    {
      "field": "firstName",
      "value": "",
      "reason": "반드시 값이 존재하고 길이 혹은 크기가 0보다 커야 합니다."
    }
  ]
}

이런 response가 날아옴.
message에 "입력값이 올바르지 않습니다." 는 ErrorCode.java에서 옴



---
B-2. @Embeddable로 Address, Email, Password 객체화



원래 dto가 이렇게 생겼잖아?

{
  "address1": "address1",
  "address2": "address2",
  "email": "mail@gmail.com",
  "firstName": "doohwan",
  "lastName": "cho",
  "password": "1234",
  "zip": "zip code"
}


근데 여기서 address, password, email을 한단계 더 객체화 시켜서, 관리하는 것.
그럼 구조가 이렇게 됨.

{
  "address": {
    "address1": "address1",
    "address2": "address2",
    "zip": "zip code"
  },
  "email": {
    "address": "string"
  },
  "firstName": "string",
  "lastName": "string",
  "password": {
    "expiration": true,
    "expirationDate": "2022-10-17T09:30:06.848Z",
    "failedCount": 0,
    "ttl": 0,
    "value": "1234"
  }
}

근데 왜 굳이 이렇게 객체화 또 시킴?

Address같은 경우에, address1, address2, zip 통합관리 해줘야 하잖아.
Password도 보면, BCryptPasswordEncoder로 encrypt하고 복호화 하고 처리하는 로직 다른 클래스에서 관리 안하고, 여기에서 비밀번호 값과 관리 메서드 일괄관리하는 것.


여튼 swagger2로 register하면, 이렇게 response 옴

{
  "email": {
    "address": "mail@gmail.com"
  },
  "password": {
    "value": "$2a$10$91xowRb891uwr7h90qwZCOU7B54.RnihsPukMKWRxF1wblVV2KGG.",
    "expirationDate": {
      "dayOfYear": 304,
      "dayOfWeek": "MONDAY",
      "month": "OCTOBER",
      "dayOfMonth": 31,
      "hour": 18,
      "minute": 31,
      "second": 2,
      "nano": 263000000,
      "year": 2022,
      "monthValue": 10,
      "chronology": {
        "id": "ISO",
        "calendarType": "iso8601"
      }
    },
    "failedCount": 0,
    "ttl": 1209604,
    "expiration": false
  },
  "firstName": "doohwan",
  "lastName": "cho",
  "address": {
    "address1": "address1",
    "address2": "address2",
    "zip": "zip code"
  }
}


AccountDto.Res에서 password만 숨기면 딱이겠다.


---
C-1. OneToMany


배송과 배송로그의 관계는 1:M 관계. 고로 json에서 이렇게 표기됨.

{
  "address": {
    "address1": "서울 특별시...",
    "address2": "신림 ....",
    "zip": "020...."
  },
  "logs": [
    {
      "status": "PENDING" //#1
    },
    {
      "status": "DELIVERING" //#2
    },
    {
      "status": "COMPLETED" //#3
    }
  ]
}


DeliveryLog는 Delivery에서 private List<DeliveryLog> logs = new ArrayList<>(); 이런식으로 관리됨.

DeliveryLog를 까보면,

@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
@ManyToOne   <--------- 이게 붙어있네?
@JoinColumn(name = "delivery_id", nullable = false, updatable = false)
private Delivery delivery;


그리고 Delivery를 까보면,
@OneToMany(mappedBy = "delivery", cascade = CascadeType.PERSIST, orphanRemoval = true, fetch = FetchType.EAGER)
private List<DeliveryLog> logs = new ArrayList<>();

@OneToMany 붙어잇고,
orphanRemoval = true 인걸 보니, 부모인 Delivery가 지워지면, 거기에 1:M으로 묶여있던 자식들 죄다 삭제하라는 말인 듯?
delete on cascade 였나.


cascade = CascadeType.PERSIST는 뭐지?
자식들 .add()하는거 트랜젝션인듯.

fetch = FetchType.EAGER는 근데 뭐지?
lazy loading, eager loading 있는데,
lazy loading은 부모 자식 1:M 관계에서, 자식들을 프록시로 lazy load하고, 실제 쓸 때, 조회함.
eager loading은 원래대로 다 쿼리해오고.





Q. 객체가 자기 자신 스스로 관리

DeliveryLog의 메서드 보면, cancel()같은 애들은 자기가 자기 케어함.
jpa에서 객체는 자기 스스로 관리하는 방식으로 짜는 듯


