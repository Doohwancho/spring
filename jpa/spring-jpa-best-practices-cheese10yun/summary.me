

---
A. annotations

a. VO on class
@Entity
@Table(name = "account")


b. VO on fields
@Id
@GeneratedValue - auto-increment
@Email
@Column(name = "email", nullable = false, unique = true) - db 제약사항 설정
@NotEmpty
@Temporal(TemporalType.TIMESTAMP)
@CreationTimestamp - 생성시 jvm 시간 기준으로 Timestamp 생성
@UpdateTimestamp - update시 jvm 시간 기준으로 Timestamp 생성




---
B. @Valid -> error 처리


vo에 @NotEmpty같은 조건 달고,
controller 파라미터에 @Valid 달아서, 조건에 부합하는지 체크,
틀리면, error 처리를 하는데,
@ControllerAdvice 를 써서 ErrorExceptionController로 컨트롤러에 프록시 담.
특정 exception이 발생하면, 캐치해서 에러 처리해주는 함수 작성. (ex. @ExceptionHandler(EmailDuplicationException.class)가 캐치)


Q. 근데 왜 별개로 에러 처리해줘야해? 기본 기능 쓰면 안돼?
A.
기본 에러 response엔 시스템 정보같은 보여주기 껄끄러운 정보들도 잡다하게 들어가있고, 포멧도 제각각임.
결국 error response 처리를 프론트엔드에서 해줘야 하는데, 포멧 통일시켜주려면, 커스텀으로 만드는게 좋다.
error response template은 ErrorResponse.java임.


example)

swagger2로 post register에 다음과 같이 필드 하나 빼고 보내면, (firstname이 비어있음)

{
  "address1": "address1",
  "address2": "address2",
  "email": "mail@gmail.com",
  "firstName": "",
  "lastName": "cho",
  "password": "1234",
  "zip": "zip code"
}


controller에 @Valid에서 제한사항 체크 중, @NotNull에 걸려서,

{
  "message": "입력값이 올바르지 않습니다.",
  "code": "???",
  "status": 400,
  "errors": [
    {
      "field": "firstName",
      "value": "",
      "reason": "반드시 값이 존재하고 길이 혹은 크기가 0보다 커야 합니다."
    }
  ]
}

이런 response가 날아옴.
message에 "입력값이 올바르지 않습니다." 는 ErrorCode.java에서 옴



---
@Embeddable로 Address, Email, Password 객체화



원래 dto가 이렇게 생겼잖아?

{
  "address1": "address1",
  "address2": "address2",
  "email": "mail@gmail.com",
  "firstName": "doohwan",
  "lastName": "cho",
  "password": "1234",
  "zip": "zip code"
}


근데 여기서 address, password, email을 한단계 더 객체화 시켜서, 관리하는 것.
그럼 구조가 이렇게 됨.

{
  "address": {
    "address1": "address1",
    "address2": "address2",
    "zip": "zip code"
  },
  "email": {
    "address": "string"
  },
  "firstName": "string",
  "lastName": "string",
  "password": {
    "expiration": true,
    "expirationDate": "2022-10-17T09:30:06.848Z",
    "failedCount": 0,
    "ttl": 0,
    "value": "1234"
  }
}

근데 왜 굳이 이렇게 객체화 또 시킴?

Address같은 경우에, address1, address2, zip 통합관리 해줘야 하잖아.
Password도 보면, BCryptPasswordEncoder로 encrypt하고 복호화 하고 처리하는 로직 다른 클래스에서 관리 안하고, 여기에서 비밀번호 값과 관리 메서드 일괄관리하는 것.


여튼 swagger2로 register하면, 이렇게 response 옴

{
  "email": {
    "address": "mail@gmail.com"
  },
  "password": {
    "value": "$2a$10$91xowRb891uwr7h90qwZCOU7B54.RnihsPukMKWRxF1wblVV2KGG.",
    "expirationDate": {
      "dayOfYear": 304,
      "dayOfWeek": "MONDAY",
      "month": "OCTOBER",
      "dayOfMonth": 31,
      "hour": 18,
      "minute": 31,
      "second": 2,
      "nano": 263000000,
      "year": 2022,
      "monthValue": 10,
      "chronology": {
        "id": "ISO",
        "calendarType": "iso8601"
      }
    },
    "failedCount": 0,
    "ttl": 1209604,
    "expiration": false
  },
  "firstName": "doohwan",
  "lastName": "cho",
  "address": {
    "address1": "address1",
    "address2": "address2",
    "zip": "zip code"
  }
}


AccountDto.Res에서 password만 숨기면 딱이겠다.



