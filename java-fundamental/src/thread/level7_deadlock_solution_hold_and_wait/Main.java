package thread.level7_deadlock_solution_hold_and_wait;

public class Main {
	
    public static void main(String[] args) {
        BreadPlate breadPlate = new BreadPlate();
        BreadMaker maker = new BreadMaker(breadPlate);
        BreadEater eater = new BreadEater(breadPlate);

        maker.setPriority(10);
        maker.start();
        eater.start();
    }

}

/*

---
what is this code?



빵집의 빵 접시에는 최대 10개의 빵이 놓일 수 있다. 

빵을 만드는 사람은 10개 이상이 빵 접시에 놓여있을 땐 만드는 것을 멈춰야하고, 
빵을 먹는 사람은 빵이 없으면 먹을 수 없어야 한다. 



---
console.log


빵을 만듬. 총 1개
빵을 만듬. 총 2개
빵을 만듬. 총 3개
빵을 만듬. 총 4개
빵을 만듬. 총 5개
빵을 만듬. 총 6개
빵을 만듬. 총 7개
빵을 만듬. 총 8개
빵을 만듬. 총 9개
빵을 만듬. 총 10개
빵 생산 초과
빵을 만듬. 총 11개
빵 생산 초과
빵을 만듬. 총 12개
빵 생산 초과
빵을 만듬. 총 13개
빵 생산 초과
빵을 만듬. 총 14개
빵 생산 초과
빵을 만듬. 총 15개
빵 생산 초과
빵을 만듬. 총 16개
빵 생산 초과
빵을 만듬. 총 17개
빵 생산 초과
빵을 만듬. 총 18개
빵 생산 초과
빵을 만듬. 총 19개
빵 생산 초과
빵을 먹음. 총 19개
빵을 먹음. 총 18개
빵을 먹음. 총 17개
빵을 먹음. 총 16개
빵을 먹음. 총 15개
빵을 먹음. 총 14개
빵을 먹음. 총 13개
빵을 먹음. 총 12개
빵을 먹음. 총 11개
빵을 먹음. 총 10개
빵을 먹음. 총 9개
빵을 먹음. 총 8개
빵을 먹음. 총 7개
빵을 먹음. 총 6개
빵을 먹음. 총 5개
빵을 먹음. 총 4개
빵을 먹음. 총 3개
빵을 먹음. 총 2개
빵을 먹음. 총 1개
빵을 먹음. 총 0개



근데 20개까지 초과생산하네?

왜지?

BreadPlate 클래스에 각각 makeBread(), eatBread() 보면, synchronized 처리가 되어있음.
두 메서드가 동기화 되었기 때문에, 하나의 쓰레드가 계속 진행하고, for문 where i < 20이 끝나면, 다음 쓰레드가 진행하는 식. 


만약에 makeBread(), eatBread()에 synchronized 처리가 안되있다?

빵을 만듬. 총 0개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 먹음. 총 0개
빵을 만듬. 총 1개
빵을 만듬. 총 1개
빵을 만듬. 총 2개
빵을 만듬. 총 3개
빵을 만듬. 총 4개
빵을 만듬. 총 5개
빵을 만듬. 총 6개
빵을 만듬. 총 7개
빵을 만듬. 총 8개
빵을 만듬. 총 9개
빵을 만듬. 총 10개
빵 생산 초과
빵을 먹음. 총 0개
빵을 먹음. 총 10개
빵을 만듬. 총 11개
빵을 만듬. 총 10개
빵 생산 초과
빵을 만듬. 총 11개
빵 생산 초과
빵을 먹음. 총 9개
빵을 먹음. 총 11개
빵을 먹음. 총 10개
빵을 먹음. 총 9개
빵을 만듬. 총 11개
빵을 만듬. 총 9개
빵을 먹음. 총 8개
빵을 먹음. 총 9개
빵을 먹음. 총 8개
빵을 먹음. 총 7개
빵을 만듬. 총 10개
빵을 먹음. 총 6개
빵을 먹음. 총 6개
빵을 먹음. 총 5개
빵을 만듬. 총 7개
빵을 만듬. 총 5개
빵을 먹음. 총 4개
빵을 만듬. 총 6개
빵을 먹음. 총 5개
빵을 먹음. 총 5개
빵을 먹음. 총 4개
빵을 먹음. 총 3개
빵을 만듬. 총 6개
빵을 먹음. 총 2개
빵을 먹음. 총 1개
빵을 먹음. 총 0개




이 사단 남.



그리고, 실전에서는 보통 무한루프가 걸려있기 때문에,
빵을 만듬만 무한으로 +1 하는 상황.
빵을 먹음은 절대 털이 안옴.


여튼, synchronized한 상태에서, 
빵 최대 10개까지만 생산하게 하고 다른 쓰레드로 넘기고 싶으면, 어떻게 해야할까?


이 때 쓰는게, 
1. Thread.wait();
2. Thread.notify();


화장실 한칸밖에 없는데 10명이 뛰어왔다.
젤 먼저 온놈이 들어가고 lock 권한을 얻었다. 
그리고 나머지 쓰레드 들은 어짜피 기다려야 하니까 스르르 잠든다. 

먼저 온 놈이 일 다 보고 화장실 밖에 나가긴 하는데,
옷가계에 하나 밖에 없는 드레스 룸 앞에서 대기타야 하는 상황이다. 
그럼 양심적으로 lock 키는 반환하고 가야되잖아? 그래야 2번쨰 애가 들어가지.

만약 아무 처리 안하면, 첫째놈이 옷 다 갈아입고 돌아온 다음에 화장실 lock 키를 반환함.
그래서 race condition에 아무처리 안해주면 성능이 느린 것.

여튼, 화장실 지금 당장 들어갈거 아닌데 lock 권한을 았다면, 
makeBread()에서 빵이 10개 이상 이미 있어서, 빵 만들게 아니라면,
.wait(); 를 해서, lock 권한을 반환하는 것.
그럼 스르르 잠든다. 


언제까지?
화장실 쓰고 싶고 대기중이었는데, 자리 빈자리 났다고 공고 떴을 때 까지.
빈 자리 났다고 공고 띄우면서, 대기중인 애들중에 한놈 깨우는게 notify();  





.wait(), .notify() 를 적용한 결과 


빵을 만듬. 총 1개
빵을 만듬. 총 2개
빵을 만듬. 총 3개
빵을 만듬. 총 4개
빵을 만듬. 총 5개
빵을 만듬. 총 6개
빵을 만듬. 총 7개
빵을 만듬. 총 8개
빵을 만듬. 총 9개
빵을 만듬. 총 10개
빵 생산 초과
빵을 먹음. 총 9개
빵을 먹음. 총 8개
빵을 먹음. 총 7개
빵을 먹음. 총 6개
빵을 먹음. 총 5개
빵을 먹음. 총 4개
빵을 먹음. 총 3개
빵을 먹음. 총 2개
빵을 먹음. 총 1개
빵을 먹음. 총 0개
빵이 없어 기다림
빵을 만듬. 총 1개
빵을 만듬. 총 2개
빵을 만듬. 총 3개
빵을 만듬. 총 4개
빵을 만듬. 총 5개
빵을 만듬. 총 6개
빵을 만듬. 총 7개
빵을 만듬. 총 8개
빵을 만듬. 총 9개
빵을 만듬. 총 10개
빵을 먹음. 총 9개
빵을 먹음. 총 8개
빵을 먹음. 총 7개
빵을 먹음. 총 6개
빵을 먹음. 총 5개
빵을 먹음. 총 4개
빵을 먹음. 총 3개
빵을 먹음. 총 2개
빵을 먹음. 총 1개
빵을 먹음. 총 0개
빵이 없어 기다림



10개 만들고, 10개 먹고
다시 10개 만들고, 10개 먹고 

깔-끔 


왜?

쓰레드 20개가 빵만들기에 달려듬.
처음 도착한 10개는 빵만듬.
근데 11번째부터 20번쨰 까지는 빵 갯수가 10개 초과라 .wait(); 메서드 걸려서
lock 권한 반납하고 스르르 잠듬.

synchronized된 20명 쓰레드가 할일 마쳤거나 스르르 잠들었으니,
eater로 context switching이 일어나면서, 

만든 10개 다 먹어버림.
근데 못먹은 11번째~20번째 까지 쓰레드는 빵 갯수가 0개 이하니 .wait(); 맞고 스르르 잠듬.

그러면서 .notify()로 10명 꺠움. 
깬 10명은 아까 잠들었던 maker 10명. 

eater 10명은 다 먹어서 끝났고, 나머지 10명은 .wait() 맞고 자고있으니까,
해당 블럭 단위 일이 다 끝났으므로, 
context switching이 일어나 다시 maker로 감.

잠깬 10명이 다시 한놈씩 synchronized로 빵 만들고
나머진 기존 패턴 반복. 




*/
