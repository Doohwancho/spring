
---
A. single thread

int num = 0;

Thread A.setNum(1);

이건 싱글 쓰레드 환경에서는 괜찮음.



---
B. multi thread

int num = 0;

Thread A.setNum(1);
Thread B.setNum(2);
Thread C.setNum(3);

근데 멀티 쓰레드 환경이라면?



---
C. problem - race condition

1. 한 자원을 여러 쓰레드가 동시 참조 -> 문제 발생 농후
2. 쓰레드들이 서로 다른 값을 참조함	
	Thread A,B,C가 RAM에 올라온 Process안에 똑같은 곳의 공유자원을 참조하는게 아니라, 성능 향상을 위해 RAM에서 카피해온 값을 자신의 CPU cache에 저장해 놓고 사용함.
	그래서 Thread A, C가 값을 바꾸면, Thread A.cache의 값과 Thread C.cache의 값이 다름(???)
3. 성능 저하 
	num자원을 A가 쓰고 바로 제자리에 반환하는게 아니라,
	다른 여러 작업 끝나고 반환하면,
	B,C는 A가 num뿐만 아니라 다른 작업 다 끝날 때 까지 기다려야 함.
4. 서순 보장 X
	Thread C->A->B 인지, B->A->C 인지 예측 불가능
	근데 서순 필요한건 굳이 병렬처리된 멀티 쓰레드 쓰지 마 ㅋㅋ. 이건 문제가 아닌 


해결 방법은 3가지.


---
D. Solution1. synchronized(동기화)


Q. 한 자원에 여러 쓰레드가 동시 참조하는 문제를 어떻게 해결하지?

A. Critical Section(임계 영역)을 정해주기.

임계영역: @Transactional 하는 최소단위. 

Critical Section 정해주고, 
Thread A가 Critical Section안에 있을 때, 다른 Thread B,C가 Critical Section안에 침범하지 못하게 보장해주

화장실에 들어갈 땐, 한번에 한놈만 들어갈 수 있어!


어떻게?

int synchronized num = 0; 하면, 

num에 대해 Thread A, Thread B, Thread C가 한번에 한놈 씩 밖에 접근할 수 없다.  



성능은 race condition보다는 좋으나, 
volatile, Atomic Class보단 떨어지는 편.



---
E. Solution2. volatile


Q. Thread A,B,C가 같은 곳의 자원을 공유하는게 아니라,
그 자원을 자기의 CPU cache에 복사해와서 값을 바꿔서 생기 문제를 어떻게 해결하지?

A. Thread A,B,C를 강제로 로컬 CPU cache쓰게 하지 말고, 공유자원 한 곳에 값을 참조하도록 하자!

그게 volatile


단!
Thread A만 write하고, 나머지 Thread B,C, ...는 read only할 때에만 volatile 쓰자.

왜?
volatile은 모든 쓰레드가 공유자원을 쓰라는거지, 
동시에 .write()했을 때 문제는 해결한 방법이 아니다. 





---
F. Solution3. Atomic Class(Compare and Swap)


Thread A,B,C가 동시에 공유자원에 int num을 바꾸려고 하는데, 3놈중 한놈만 자원을 바꾸게 하고싶다. 어떻게?

CAS(compare and swap algorithm)을 사용하자!

int num = 10; 일 때,

ThreadA.set(oldVal, updateVal);
ThreadB.set(oldVal, updateVal);
ThreadC.set(oldVal, updateVal);

해서, oldVal이 10과 같으면 updateVal로 바꾸도록 하자.(이게 CAS)


ex.

int num = 10;

ThreadA.set(10, 200);
ThreadB.set(10, 300);
ThreadC.set(10, 400);


쓰레드 A,B,C가 동시에 공유자원 num에게 접근한다.
가장 먼저 도착한 ThreadB가 oldVal == 10이니까, num = 300; 한다.


int num = 300;

ThreadA.set(10, 200);
ThreadC.set(10, 400);

그럼 ThreadA,C는 oldVal인 10과 현재 공유자원의 값인 300이 다르기 때문에, .set()이 안되고 while()문에서 무한 return false loop 걸려 대기된다.





