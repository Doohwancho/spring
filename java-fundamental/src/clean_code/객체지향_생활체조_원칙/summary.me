
---
goal


좋은 품질의 소프트웨어 생산을 위해,

1. 응집도(cohension)
2. 느슨한 결합(loose coupling)
3. 무중복(zero duplication)
4. 캡슐화(encapsulation)
5. 테스트 가능성(testability)
6. 가독성(readability)
7. 초점(focus)

... 을 실현하기 위한 원칙

아따 말은 번지르르 허이


---
원칙


원칙1. 한 메서드에 오직 한 단계의 들여 쓰기만 한다.
원칙2. else 예약어를 쓰지 않는다.
원칙3. 모든 원시값과 문자열을 포장한다.
원칙4. 한 줄에 점을 하나만 찍는다.
원칙5. 줄여쓰지 않는다(축약 금지)
원칙6. 모든 엔티티를 작게 유지한다.
원칙7. 3개 이상 인스턴스 변수를 가진 클래스를 쓰지 않는다.
원칙8. 일급 컬렉션을 쓴다.
원칙9. Getter, Setter, Property를 사용하지 않는다.



---
my guess -> correction.


원칙1. nest하지 말라 -> 코드 가독성 떨어진다 -> 함수형 쓰면 해-결! ㅋㅋ. 아님 로직별로 잘게 나누던가.
원칙2. if(certain condition is met) return; 을 앞에 박고 나머지 로직 쓰라는 말인듯? -> ㅇㅇ 맞음.
원칙3. primitive type쓰지 말고 wrapper class쓰란말 같은데, 안애 .sort()라던지 내장함수가 표준으로 이미 있어서, 다른사람과 공유해서 쓰기 편하고, 객체니까 null처리 핸들링도 더 수월할거고. 함수형에 Predicate인가? Optional인가? 써서. -> 원시형 타입은 의도가 없으니, 커스텀 wrapper class로 의도부여 + null check 등 하라는 것
원칙4. ???? 객체 참조를 하나만 하라는 말인가? @Builder패턴 보면 각 property 주입할 떄마다 내려쓰기 하긴 하는데, 함수형을 보면, 쭉 기차처럼 점찍어서 잇던데. 그래도 너무 길지만 않으면 괜찮지 않나? rule-of-six에서 보면, 한 영역에서 생각해야할게 6개 이하면 괜찮다던데. -> 읽어보니 method chaining은 예외라고 함. 단위변환같은거 할 때, @Getter이나 내부함수 여러개 조합해서 지저분하게 쓰지 말고, 전용함수 만들라는 것인 듯.
원칙5. 이건 좀 공감. 여러 사람 협업하는데 나만아는 줄임말 쓰면 어쩔꺼야. 근데 애초에 협업하는 환경에선 이미 코딩 컨벤션 만들고 시작해서 약속대로 쓰기 때문에, 이건 불필요하지 않나?
원칙6. 이건 SOLID랑 맞닿아 있는 듯
원칙7. 인스턴스 변수라는게 DI말고 = new Object()로  바로 선언하는걸 말하는거겠지? 싱글턴같은 애들. -> 그 말이 아니라 extends 같은 애들로 쪼갤 때, 더 세분하게 쪼개라는 말 같은데?
원칙8. 일급 컬렉션? Collection에도 종류가 또 있나? 일급 함수같은건 아닐테고. -> 3번처럼 custom wrapper class 만들어서 안에 내장으로 유효성 처리 하라는 말인 듯
원칙9. 이건 뭔소리야 getter setter 안쓰면 아 @Data 쓰라는건가? -> 아예 쓰지 말라는말이 아니라, 외부에서 남발하지 말라는 것. Integer ratio = person.getWeight()/person.getAge(); 이렇게 getter 남발할 바에야 내부에서 메서드 하나 만들어주라는 말. don't ask, just tell.